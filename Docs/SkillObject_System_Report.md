# 스킬 오브젝트 시스템 - 분석 및 새 설계 보고서

---

# 1부: 기존 시스템 분석

---

## 1. 기존 코드 구조 요약

```
AUKInstancePoolActor (오브젝트 풀 관리)
  └── AUKSkillObjectBase (스킬 오브젝트 공통 베이스)
        ├── AUKProjectileBase     (투사체 - 날아가서 맞히는 것)
        ├── AUKAoEObjectBase       (범위 공격 - 바닥에 깔리는 것)
        └── AUKShockwaveBase       (충격파 - 퍼져나가는 고리)
```

### 각 클래스가 하는 일

| 클래스 | 역할 | 파라미터 전달 방식 |
|--------|------|--------------------|
| **SkillObjectBase** | 공통 베이스. ASC 보유, 스킬 컴포넌트 보유, `UseSkill()` 진입점 | `FInstancedStruct` → `FUKSkillParamsBase` |
| **ProjectileBase** | 직선 날아가는 투사체. SphereComponent + ProjectileMovement | `FUKProjectileParams` (속도, 배율, 원거리공격데이터) |
| **AoEObjectBase** | 바닥에 놓이는 범위 장판. 시간/주기로 반복 공격 | `FUKAoEAttackInfo` (지속시간, 주기) |
| **ShockwaveBase** | 퍼져나가는 고리형 충격파. 안쪽/바깥쪽 반경이 시간에 따라 확장 | `FUKShockwaveAttackInfo` (반경들, 높이, 타입) |

### 기존 흐름 (투사체 예시)

```
1. 어빌리티가 SkillObject를 소환
2. UseSkill(파라미터) 호출
3. OnUseSkillParams()로 파라미터 전달
4. ProjectileMovement에 속도 설정 → 날아감
5. 충돌 발생 → OnProjectileHit / OnProjectileOverlapped
6. 관계 확인 (아군이면 무시)
7. 면역 태그 확인
8. bDirectAttack이면 직접 데미지 → 파괴
9. 아니면 TryActivateAllAbilities() → 어빌리티가 데미지 처리 → 파괴
```

---

## 2. 기존 시스템의 문제점

### 구조 문제

#### 문제 1: 새 공격 타입마다 새 클래스가 필요하다

지금은 투사체/범위/충격파 세 가지만 있다. 유도 미사일, 부메랑, 공전하는 방패, 체인 라이트닝, 소환수 등을 만들려면 매번 새로운 C++ 클래스를 만들어야 한다.

```
현재: 3종류 = 3개 클래스
목표: 20종류 = 20개 클래스? ← 관리 불가능
```

#### 문제 2: 코드가 반복된다

`AUKProjectileBase`의 `OnProjectileHit`과 `OnProjectileOverlapped`는 거의 똑같은 코드다.
둘 다 관계 확인 → 면역 확인 → 플레이어만 체크 → 직접공격/어빌리티 분기를 동일하게 수행한다.
약 40줄이 거의 복사-붙여넣기 수준으로 중복되어 있다.

#### 문제 3: 필터링이 클래스마다 다르다 (일관성 없음)

| 클래스 | 관계 확인 | 면역 확인 | 플레이어만 옵션 |
|--------|-----------|-----------|-----------------|
| ProjectileBase | O (EntityManager) | O (Immune_Damage 태그) | O (bOnlyPlayerHit) |
| AoEObjectBase | **X (없음!)** | **X (없음!)** | **X (없음!)** |
| ShockwaveBase | **X (없음!)** | **X (없음!)** | **X (없음!)** |

AoE와 Shockwave는 아군/적군 구분 없이 감지된 모든 대상에게 어빌리티를 실행한다.
이것은 버그가 될 가능성이 높다.

#### 문제 4: 스킬 오브젝트마다 ASC를 가지고 있다

모든 스킬 오브젝트가 자기만의 `UUKAbilitySystemComponent`를 갖고 있다.
투사체 100발을 쏘면 ASC가 100개 생긴다.
ASC는 무거운 컴포넌트다. 스킬 오브젝트는 데미지를 "전달"만 하면 되므로, 시전자의 ASC를 빌려 쓰는 것이 맞다.

#### 문제 5: 단일 단계만 지원한다

파이어볼이 날아가서 적중하면 폭발 범위 데미지를 주는 "2단계 스킬"을 만들 수 없다.
현재 구조에서는 적중 → 파괴가 끝이다.
"투사체 → 폭발", "투사체 → 분열 → 소형 투사체" 같은 연쇄가 불가능하다.

#### 문제 6: 동시에 여러 개 소환 기능이 없다

부채꼴 3발 동시 발사, 원형으로 8개 소환 같은 패턴을 지원하는 구조가 없다.
소환 패턴은 어빌리티 쪽에서 별도로 구현해야 하는데, 그 구조가 없다.

### 사용성 문제

#### 문제 7: 데이터 주도가 아니다

새 스킬을 만들려면 반드시 C++ 코드를 수정해야 한다.
기획자가 에디터에서 드롭다운을 선택해 새 스킬을 조합할 수 없다.

#### 문제 8: 파라미터가 뒤섞인다

`FUKProjectileParams`에는 투사체 전용 데이터와 공통 데이터가 섞여 있다.
유도 미사일을 만들면 `FUKHomingParams`를 새로 만들어야 하는데, 직선 투사체 전용 필드도 보인다.

### 안정성 문제

#### 문제 9: Destroy() 직접 호출

오브젝트 풀(`AUKInstancePoolActor`)을 상속받았지만, `AoEObjectBase`와 `ShockwaveBase`는 `Destroy()`를 직접 호출한다.
풀에 반환하는 것이 아니라 완전히 파괴하므로 풀 시스템의 이점을 살리지 못한다.

#### 문제 10: 충돌 토글 방식 (해킹에 가까움)

`AoEObjectBase`의 주기적 공격은 이렇게 동작한다:
```cpp
// 충돌을 끄고 → 다시 켜서 → 오버랩을 강제로 다시 발생시킴
ShapeComponent->SetCollisionEnabled(ECollisionEnabled::NoCollision);
ShapeComponent->SetCollisionEnabled(PrevType);
```
이것은 정상적인 방법이 아니다. 타이머를 사용해서 범위 내 대상을 직접 검색하는 것이 안정적이다.

#### 문제 11: 동기 에셋 로딩

```cpp
UNiagaraSystem* LoadedFx = Cast<UNiagaraSystem>(AoEFx.LoadSynchronous());
```
`LoadSynchronous()`는 게임 스레드를 멈추고 에셋을 로딩한다.
투사체가 많이 생성되는 상황에서 프레임 드랍의 원인이 된다.

#### 문제 12: 투사체 최대 수명이 없다

투사체가 아무것도 안 맞고 계속 날아가면 영원히 존재한다.
`ProjectileMovement`에 기본 수명 제한이 설정되어 있지 않다.

#### 문제 13: 리플리케이션 설정 (싱글플레이어인데)

```cpp
AbilitySystemComponent->SetIsReplicated(true);
AbilitySystemComponent->SetReplicationMode(EGameplayEffectReplicationMode::Mixed);
```
싱글플레이어 게임에서 리플리케이션은 불필요한 비용이다.

---

# 2부: 새 시스템 설계

---

## 3. 핵심 생각

**스킬 오브젝트의 일생**을 단계별로 나누고, 각 단계를 **교체 가능한 조각**으로 만든다.

스킬 오브젝트의 일생:
```
[소환] → [이동] → [감지] → [필터] → [효과] → [타이밍] → [수명] → (다음 단계?)
어디서    어떻게    뭘       누구에게   뭘       언제       언제까지
얼마나    움직여?   찾아?    적용?     적용?    적용?     살아있어?
소환?
```

각 단계를 **독립적인 조각(정책)**으로 만들면:
- 직선 이동 + 구체 감지 + 적만 필터 + 데미지 효과 = **파이어볼**
- 정지 + 구체 감지 + 아군만 필터 + 힐 효과 = **힐링 서클**
- 유도 이동 + 구체 감지 + 적만 필터 + 데미지 효과 = **유도 미사일**

**같은 조각의 다른 조합**으로 완전히 다른 스킬이 된다.

---

## 4. 전체 구조

```
┌─────────────────────────────────────────────────────┐
│                  GameplayAbility                      │
│              (스킬을 시전하는 어빌리티)                │
│                                                       │
│  ┌─────────────────────────────────┐                  │
│  │     SpawnRule (소환 규칙)        │                  │
│  │  - 어디서? 몇 개? 어떤 배치로?  │                  │
│  └──────────────┬──────────────────┘                  │
└─────────────────┼─────────────────────────────────────┘
                  │ 소환
                  ▼
┌─────────────────────────────────────────────────────┐
│              SkillObject (스킬 오브젝트)              │
│              ─ 하나의 액터 클래스 ─                   │
│                                                       │
│  ┌──────────┐  ┌──────────┐  ┌──────────┐           │
│  │  이동     │  │  감지     │  │  필터     │           │
│  │ Movement │  │ Detection│  │  Filter  │           │
│  └────┬─────┘  └────┬─────┘  └────┬─────┘           │
│       │              │              │                  │
│       │         감지됨!         걸러냄!               │
│       │              │              │                  │
│  ┌────┴─────┐  ┌────┴─────┐  ┌────┴─────┐           │
│  │  타이밍   │  │  효과     │  │  수명     │           │
│  │ Timing   │  │  Effect  │  │ Lifetime │           │
│  └──────────┘  └──────────┘  └────┬─────┘           │
│                                    │                  │
│                              수명 끝! →  다음 단계?   │
└─────────────────────────────────────────────────────┘
                                     │
                                     ▼
                            다음 SkillObject 소환
                            (폭발, 분열 등)
```

### 핵심 설계 결정

| 결정 | 선택 | 이유 |
|------|------|------|
| 소환 규칙의 위치 | 어빌리티 안에 | 오브젝트는 "자기가 어떻게 소환됐는지" 알 필요 없음. 같은 투사체도 1발/3발/부채꼴 등 다양하게 소환 가능 |
| 각 단계 구현 방식 | UObject 조각 (EditInlineNew) | 에디터에서 드롭다운 선택, 새 종류 추가 시 기존 코드 수정 불필요 |
| 스킬 오브젝트 클래스 수 | **하나** (AOKSkillObject) | 서브클래스 폭발 방지. 조합으로 모든 타입 표현 |
| ASC 소유 | 시전자의 ASC 사용 | 오브젝트마다 ASC 만드는 비용 제거 |
| 데이터 관리 | DataAsset | 에디터에서 만들고 조합. C++ 수정 없이 새 스킬 생성 |
| 단계 연결 | 수명 끝 → 다음 DataAsset 소환 | 파이어볼→폭발, 분열→소형 투사체 등 연쇄 가능 |

---

## 5. 각 단계 상세 설계

---

### 5.1 소환 규칙 (SpawnRule) — 어빌리티 안에 있음

> "어디서, 몇 개를, 어떤 배치로 소환할 것인가"

소환 규칙은 **어빌리티**에 속한다. 같은 투사체 DataAsset을 1발로 쏘든, 부채꼴 5발로 쏘든, 투사체 자체는 동일하기 때문이다.

#### 소환 규칙 종류

| 이름 | 설명 | 설정값 |
|------|------|--------|
| **앞에서 (Forward)** | 시전자 앞에 1개 소환 | 앞으로 거리, 위로 높이 |
| **지정 위치 (AtLocation)** | 커서/타겟 위치에 소환 | (게임 중 위치 결정) |
| **타겟 위에 (AtTarget)** | 잠금된 타겟 위치에 소환 | 높이 보정값 |
| **하늘에서 (FromSky)** | 높은 곳에서 아래로 | 높이, 개수, 흩어짐 범위 |
| **부채꼴 (FanSpread)** | 부채꼴로 여러 개 | 개수, 벌어짐 각도 |
| **원형 (CircleRing)** | 원형으로 둘러싸며 | 개수, 반경 |
| **랜덤 범위 (RandomArea)** | 범위 안 랜덤 위치에 | 개수, 반경, 최소 간격 |

#### 소환 규칙이 하는 일 (1가지만)

```
입력: 시전자 위치, 시전 방향, 타겟 위치 (있으면)
출력: FTransform 배열 (소환할 위치/회전 목록)
```

예시:
- FanSpread(개수=3, 각도=30도) → 3개의 Transform 반환 (왼쪽15도, 정면, 오른쪽15도)
- FromSky(높이=1000, 개수=5, 범위=500) → 5개의 Transform 반환 (하늘 높이에 랜덤 위치)

#### 소환 규칙 안의 추가 설정

| 설정 | 설명 | 기본값 |
|------|------|--------|
| 소환 간격 (SpawnDelay) | 여러 개 소환 시 시간 차이 | 0 (동시) |
| 소환 대상 DataAsset | 어떤 스킬 오브젝트를 소환할지 | (필수) |
| 소켓 사용 여부 | 무기/메시 소켓에서 소환할지 | false |
| 소켓 이름 | 사용할 소켓 | "Muzzle" |

---

### 5.2 이동 (Movement) — 스킬 오브젝트 안

> "소환된 후 어떻게 움직이는가"

#### 이동 종류

| 이름 | 설명 | 설정값 |
|------|------|--------|
| **정지 (Static)** | 소환 위치에 고정 | 없음 |
| **직선 (Straight)** | 앞으로 쭉 날아감 | 속도, 중력 영향 |
| **유도 (Homing)** | 타겟을 따라감 | 속도, 선회력, 유도 시작 시간 |
| **따라가기 (FollowOwner)** | 시전자를 따라다님 | 거리 유지값, 따라가는 빠르기 |
| **공전 (Orbit)** | 시전자 주위를 돈다 | 반경, 회전 속도 (초당 각도) |
| **부메랑 (Boomerang)** | 나갔다가 돌아옴 | 전진 속도, 최대 거리, 복귀 속도 |
| **물결 (Wave)** | 사인파로 흔들리며 이동 | 속도, 흔들림 폭, 흔들림 빈도 |
| **낙하 (Falling)** | 중력으로 떨어짐 | 초기 속도, 중력 배율 |
| **확장 고리 (ExpandingRing)** | 고리가 퍼져나감 | 시작 반경, 끝 반경, 확장 시간 |

#### 이동이 하는 일

```
매 프레임:
  1. 현재 위치와 상태를 받음
  2. 새 위치를 계산
  3. 오브젝트를 이동시킴
```

#### 이동 안의 공통 설정

| 설정 | 설명 |
|------|------|
| 최대 속도 | 속도 제한 |
| 시작 지연 | 소환 후 N초 뒤에 이동 시작 |
| 가속도 | 시간에 따라 속도 증가/감소 |

---

### 5.3 감지 (Detection) — 스킬 오브젝트 안

> "어떤 모양으로 대상을 찾는가"

#### 감지 종류

| 이름 | 설명 | 설정값 |
|------|------|--------|
| **구체 (Sphere)** | 구체 형태 오버랩 | 반경 |
| **박스 (Box)** | 직육면체 형태 오버랩 | 가로, 세로, 높이 |
| **캡슐 (Capsule)** | 캡슐 형태 오버랩 | 반경, 반높이 |
| **부채꼴 (Cone)** | 전방 부채꼴 모양 | 각도, 거리 |
| **직선 (Ray)** | 직선 레이캐스트 | 길이, 검사 주기 |
| **고리 (Ring)** | 안쪽/바깥쪽 반경 사이 도넛 모양 | 안쪽 반경, 바깥쪽 반경, 높이 |

#### 감지가 하는 일

```
1. 감지 범위 생성 (Collision Shape 또는 Sweep)
2. 범위 안에 들어온 액터 목록을 필터에 전달
```

#### 감지 안의 공통 설정

| 설정 | 설명 |
|------|------|
| 시전자 무시 | 시전자를 감지에서 제외 (기본: true) |
| 충돌 채널 | 어떤 충돌 채널을 사용할지 |
| 디버그 표시 | 에디터에서 감지 범위 시각화 |

---

### 5.4 필터 (Filter) — 스킬 오브젝트 안

> "감지된 대상 중 누구에게 효과를 줄 것인가"

#### 필터 종류

| 이름 | 설명 | 설정값 |
|------|------|--------|
| **적만 (EnemyOnly)** | 시전자의 적만 통과 | 없음 |
| **아군만 (AllyOnly)** | 시전자의 아군만 통과 | 없음 |
| **자기 자신만 (SelfOnly)** | 시전자 자신만 통과 | 없음 |
| **모두 (All)** | 모든 대상 통과 | 없음 |
| **태그 기반 (TagBased)** | 특정 태그가 있는/없는 대상 | 필요한 태그, 차단 태그 |
| **파괴물 (Destructible)** | 부술 수 있는 오브젝트만 | 없음 |
| **복합 (Composite)** | 여러 필터를 AND/OR로 조합 | 필터 목록, 조합 방식 |

#### 필터가 하는 일

```
입력: 감지된 액터 1개
출력: 통과(true) 또는 차단(false)

판정 순서:
  1. 관계 확인 (EntityManager 사용)
  2. 면역 태그 확인 (Immune_Damage 등)
  3. 이미 맞은 대상인지 확인
  4. 최대 대상 수 확인
```

#### 필터 안의 공통 설정

| 설정 | 설명 | 기본값 |
|------|------|--------|
| 시전자 제외 | 자기 자신에게 효과 안 줌 | true |
| 중복 적중 방지 | 같은 대상에게 다시 안 맞힘 | true |
| 최대 대상 수 | 한 번에 효과 줄 수 있는 최대 수 | 0 (무제한) |
| 면역 태그 확인 | 면역 상태인 대상 자동 제외 | true |

---

### 5.5 효과 (Effect) — 스킬 오브젝트 안

> "필터를 통과한 대상에게 무엇을 하는가"

#### 효과 종류

| 이름 | 설명 | 설정값 |
|------|------|--------|
| **데미지 (Damage)** | GE로 데미지 적용 | GE 클래스, 데미지 태그, 배율 |
| **힐 (Heal)** | GE로 체력 회복 | GE 클래스, 힐량 태그, 배율 |
| **버프 (Buff)** | GE로 버프/디버프 부여 | GE 클래스 |
| **밀어내기 (Knockback)** | 밀어내는 힘 적용 | 방향(중심에서/고정), 세기, GE 클래스 |
| **끌어당기기 (Pull)** | 중심으로 끌어당기기 | 세기, GE 클래스 |
| **스킬오브젝트 소환 (SpawnObject)** | 맞은 대상 위치에 새 스킬오브젝트 소환 | 소환할 DataAsset |
| **복합 (Multi)** | 위 효과 여러 개 동시 적용 | 효과 목록 |

#### 효과가 하는 일

```
입력: 대상 액터, 시전자 정보 (ASC, GE 스펙)
동작: 시전자의 ASC를 통해 대상에게 GameplayEffect 적용
```

**핵심: 시전자의 ASC를 빌려 쓴다**

기존 시스템은 오브젝트마다 ASC를 갖고 있었다.
새 시스템은 시전자의 ASC로 효과를 적용한다.
오브젝트는 "누가 쐈는지" 기억하고, 그 시전자의 ASC에 "이 대상에게 이 효과를 줘" 라고 요청한다.

#### 효과 안의 공통 설정

| 설정 | 설명 |
|------|------|
| GameplayEffect 클래스 | 적용할 GE |
| SetByCaller 태그 + 값 | GE에 전달할 동적 값 (데미지량 등) |
| 배율 | 기본 값에 곱할 배수 |
| 히트 정보 전달 | 맞은 위치/방향 등을 GE 컨텍스트에 포함 |

---

### 5.6 타이밍 (Timing) — 스킬 오브젝트 안

> "효과를 언제 발동하는가"

#### 타이밍 종류

| 이름 | 설명 | 설정값 |
|------|------|--------|
| **접촉시 (OnOverlap)** | 감지 범위에 들어오면 즉시 | 대상당 최대 적중 횟수 |
| **주기적 (Periodic)** | N초마다 범위 안의 모든 대상에게 | 주기 (초) |
| **소멸시 (OnExpire)** | 오브젝트가 사라질 때 1번 | 없음 |
| **연쇄 (Chain)** | 맞은 후 근처 다른 대상으로 점프 | 최대 연쇄 횟수, 탐색 반경, 점프 간격 |
| **지연 (Delayed)** | 감지 후 N초 뒤에 발동 | 지연 시간 |

#### 타이밍이 하는 일

```
감지에서 대상 발견됨
  ↓
타이밍이 "지금 효과를 줄까?" 결정
  ↓
[접촉시] → 즉시 줌
[주기적] → 타이머 확인 후 줌
[소멸시] → 나중에 소멸할 때 줌
[연쇄]   → 줌 + 다음 대상 탐색 예약
[지연]   → 타이머 예약 후 나중에 줌
```

#### 타이밍 안의 공통 설정

| 설정 | 설명 |
|------|------|
| 첫 발동 지연 | 소환 직후 N초간 발동 안 함 (자기에게 안 맞도록) |

---

### 5.7 수명 (Lifetime) — 스킬 오브젝트 안

> "언제 사라지는가, 사라질 때 무엇을 하는가"

#### 수명 종료 조건

| 이름 | 설명 | 설정값 |
|------|------|--------|
| **시간 (Timer)** | N초 후 소멸 | 지속 시간 |
| **첫 적중 (FirstHit)** | 처음 뭔가에 맞으면 소멸 | 없음 |
| **적중 횟수 (HitCount)** | N번 맞으면 소멸 | 최대 적중 수 |
| **벽 충돌 (WallHit)** | 벽에 부딪히면 소멸 | 없음 |
| **수동 (Manual)** | 시전자가 취소할 때까지 | 없음 |
| **사거리 (MaxDistance)** | 일정 거리 이동 후 소멸 | 최대 거리 |
| **복합 (Composite)** | 조건 여러 개 조합 (OR: 하나라도 충족 시 소멸) | 조건 목록 |

#### 소멸 시 행동

수명이 끝나면 "뭘 할 것인가"도 정해야 한다.

| 이름 | 설명 | 설정값 |
|------|------|--------|
| **그냥 사라짐 (None)** | 조용히 사라짐 | 없음 |
| **다음 단계 소환 (SpawnNext)** | 다른 스킬오브젝트를 소환 | 다음 DataAsset, 소환 규칙 |
| **폭발 (Explode)** | 폭발형 스킬오브젝트 소환 | 폭발 DataAsset |

**이것이 "단계 연결"의 핵심이다.**

```
[파이어볼 DataAsset]
  수명: 첫적중 소멸
  소멸 시: → [폭발 DataAsset] 소환

[폭발 DataAsset]
  이동: 정지
  감지: 구체(반경 300)
  효과: 범위 데미지
  수명: 0.1초 후 소멸
  소멸 시: → 없음
```

```
[분열 화살 DataAsset]
  수명: 2초 후 소멸
  소멸 시: → [소형 화살 DataAsset] x 3개 부채꼴 소환

[소형 화살 DataAsset]
  이동: 직선
  수명: 적중 소멸
  소멸 시: → 없음
```

#### 수명 안의 공통 설정

| 설정 | 설명 | 기본값 |
|------|------|--------|
| 최대 수명 (안전장치) | 무슨 일이 있어도 이 시간 후 소멸 | 30초 |
| 소멸 이펙트 | 사라질 때 나이아가라 이펙트 | 없음 |
| 소멸 사운드 | 사라질 때 소리 | 없음 |
| 소멸 시 카메라 흔들림 | 사라질 때 화면 흔들기 | 없음 |

---

## 6. DataAsset 구조

### 스킬 오브젝트 DataAsset (하나의 스킬 오브젝트를 정의)

```
UOKSkillObjectDataAsset (PrimaryDataAsset)
│
├── 기본 정보
│   ├── 이름 (DisplayName)
│   ├── 충돌 설정 (CollisionPreset)
│   └── 메시/이펙트 참조
│
├── [이동] UOKMovement*         ← 드롭다운에서 선택
├── [감지] UOKDetection*        ← 드롭다운에서 선택
├── [필터] UOKFilter*           ← 드롭다운에서 선택
├── [효과] UOKEffect*           ← 드롭다운에서 선택
├── [타이밍] UOKTiming*         ← 드롭다운에서 선택
├── [수명] UOKLifetime*         ← 드롭다운에서 선택
│
├── 연출 정보
│   ├── 소환 이펙트 (Niagara)
│   ├── 비행 이펙트 (Niagara)
│   ├── 적중 이펙트 (Niagara)
│   ├── 소멸 이펙트 (Niagara)
│   ├── 소환 소리 (Sound)
│   ├── 비행 소리 (Sound)
│   ├── 적중 소리 (Sound)
│   └── 소멸 소리 (Sound)
│
└── 소멸 후 다음 단계
    ├── 다음 DataAsset (TSubclassOf 또는 SoftObjectPtr)
    └── 다음 소환 규칙 (UOKSpawnRule*)
```

### 에디터에서 보이는 모습 (개념)

```
[DA_Fireball]
  ┌─ 이동 ──────── [직선 (Straight)]      ▼
  │                  속도: 2000
  │                  중력: 0
  │
  ├─ 감지 ──────── [구체 (Sphere)]         ▼
  │                  반경: 30
  │
  ├─ 필터 ──────── [적만 (EnemyOnly)]      ▼
  │
  ├─ 효과 ──────── [데미지 (Damage)]       ▼
  │                  GE: GE_FireDamage
  │                  배율: 1.5
  │
  ├─ 타이밍 ────── [접촉시 (OnOverlap)]    ▼
  │                  대상당 최대: 1
  │
  ├─ 수명 ──────── [첫적중 (FirstHit)]     ▼
  │
  └─ 소멸 후 ───── [DA_Fireball_Explosion]
                    소환규칙: [지정위치 (AtLocation)]
```

---

## 7. 어빌리티 연동

### 스킬 오브젝트 어빌리티 구조

```
UOKGameplayAbility_SkillObject : UUKSkillAbility
│
├── SpawnRule (UOKSpawnRule*)    ← 소환 규칙
├── SkillObjectDataAsset        ← 어떤 오브젝트를 소환할지
│
├── ActivateAbility() 흐름:
│   1. SpawnRule로 소환 위치 목록 계산
│   2. 각 위치에 SkillObject 소환 (풀에서 가져오기)
│   3. SkillObject.Initialize(DataAsset, 시전자 정보)
│   4. 끝 (오브젝트가 알아서 동작)
│
└── 시전자 정보 (전달할 것):
    ├── 시전자 액터
    ├── 시전자 ASC
    ├── 타겟 액터 (있으면)
    ├── 타겟 위치 (있으면)
    └── GE 스펙 핸들 (미리 만든 것)
```

### 실행 흐름 상세

```
1. 플레이어가 스킬 사용
2. SkillComponent.UseSkillBySkillName("Fireball")
3. UOKGameplayAbility_SkillObject.ActivateAbility()
4. SpawnRule.CalculateSpawnTransforms(시전자위치, 방향, 타겟)
   → FTransform[1] 반환 (앞에서 1개)
5. 각 Transform마다:
   a. 오브젝트 풀에서 SkillObject 하나 꺼냄
   b. SkillObject.Initialize(DataAsset, 시전자정보)
6. SkillObject 내부:
   a. DataAsset에서 6개 정책을 읽어 초기화
   b. Movement.Initialize() → 직선 이동 시작
   c. Detection이 충돌 감지 시작
7. 투사체가 날아가면서...
8. Detection: 적을 감지함!
9. Filter: 적인지 확인 → 적이 맞음
10. Timing: 접촉시 발동 → 지금 발동!
11. Effect: 시전자ASC → 대상에게 GE_FireDamage 적용
12. Lifetime: 첫적중 → 소멸 결정
13. 소멸 처리:
    a. 소멸 이펙트 재생
    b. 다음 단계 있음 → DA_Fireball_Explosion 소환
    c. 오브젝트 풀에 반환
14. 폭발 오브젝트가 생성되어 범위 데미지 진행
```

---

## 8. 스킬 예시 조합표

### 기본 스킬들

| 스킬 | 이동 | 감지 | 필터 | 효과 | 타이밍 | 수명 | 소멸 후 |
|------|------|------|------|------|--------|------|---------|
| **파이어볼** | 직선(2000) | 구체(30) | 적만 | 데미지(1.5배) | 접촉시 | 첫적중 | → 폭발 |
| **힐링 서클** | 정지 | 구체(300) | 아군만 | 힐(0.3배) | 주기적(1초) | 시간(8초) | 없음 |
| **유도 화살** | 유도(800, 선회5000) | 구체(20) | 적만 | 데미지(1.0배) | 접촉시 | 첫적중 | 없음 |
| **독구름** | 정지 | 구체(200) | 적만 | 데미지(0.2배) | 주기적(0.5초) | 시간(6초) | 없음 |
| **공전 방패** | 공전(반경150, 180도/초) | 구체(40) | 적만 | 데미지(0.5배) | 접촉시 | 시간(12초) | 없음 |
| **메테오** | 낙하(중력2배) | 구체(50) | 적만 | 데미지(3.0배) | 접촉시 | 벽충돌 | → 폭발 |
| **체인 라이트닝** | 직선(5000) | 구체(20) | 적만 | 데미지(1.0배) | 연쇄(5회, 반경500) | 연쇄끝 | 없음 |
| **부메랑** | 부메랑(1500, 거리800) | 구체(50) | 적만 | 데미지(0.8배) | 접촉시 | 복귀완료 | 없음 |
| **얼음 장벽** | 정지 | 박스(200,50,200) | 모두 | 밀어내기(세기1000) | 접촉시 | 시간(5초) | 없음 |
| **블리자드** | 따라가기(위 500) | 구체(400) | 적만 | 복합(데미지+디버프) | 주기적(0.5초) | 시간(10초) | 없음 |

### 소환 패턴 예시

| 스킬 사용 시 | 소환 규칙 | 소환 대상 |
|-------------|-----------|-----------|
| 파이어볼 시전 | 앞에서(거리100) × 1개 | DA_Fireball |
| 멀티샷 시전 | 부채꼴(3개, 30도) | DA_Arrow |
| 메테오 시전 | 하늘에서(높이1500, 5개, 범위500) | DA_Meteor |
| 공전 방패 시전 | 원형(3개, 반경150) | DA_OrbitalShield |
| 독구름 시전 | 지정위치 × 1개 | DA_PoisonCloud |
| 화살비 시전 | 랜덤범위(20개, 반경600) | DA_RainArrow |

### 연쇄(다단계) 스킬 예시

**폭발 화살:**
```
[1단계] DA_ExplosiveArrow
  이동: 직선(1500)
  수명: 첫적중
  소멸 후: → DA_Explosion (지정위치에 소환)

[2단계] DA_Explosion
  이동: 정지
  감지: 구체(300)
  효과: 범위 데미지(2.0배)
  수명: 시간(0.1초)
  소멸 후: 없음
```

**분열 미사일:**
```
[1단계] DA_SplitMissile
  이동: 직선(1000)
  수명: 시간(1.5초)
  소멸 후: → DA_MiniMissile (부채꼴 3개, 30도)

[2단계] DA_MiniMissile
  이동: 유도(800, 선회3000)
  수명: 첫적중 또는 시간(3초)
  소멸 후: 없음
```

**연쇄 번개:**
```
[1단계] DA_ChainLightning
  이동: 직선(5000)
  감지: 구체(20)
  타이밍: 연쇄(5회, 탐색반경500, 간격0.1초)
  수명: 연쇄 완료 후 소멸
  소멸 후: 없음
```

**화염 토네이도:**
```
[1단계] DA_FireTornado
  이동: 따라가기(위 0, 앞 300)
  감지: 구체(200)
  효과: 복합(데미지 + 밀어내기)
  타이밍: 주기적(0.3초)
  수명: 시간(6초)
  소멸 후: → DA_FireField (지정위치에 소환)

[2단계] DA_FireField
  이동: 정지
  감지: 구체(250)
  효과: 데미지(0.3배)
  타이밍: 주기적(1.0초)
  수명: 시간(4초)
  소멸 후: 없음
```

---

## 9. 기존 시스템과 새 시스템 비교

| 항목 | 기존 시스템 | 새 시스템 |
|------|------------|-----------|
| 새 공격 타입 추가 | 새 C++ 클래스 필요 | DataAsset 1개 만들기 (C++ 불필요) |
| 새 이동 방식 추가 | 새 클래스 전체 작성 | UOKMovement 하위 클래스 1개 (50줄 이내) |
| 필터링 일관성 | 클래스마다 다름 (투사체만 있음) | 모든 오브젝트가 동일한 필터 사용 |
| ASC 비용 | 오브젝트마다 ASC 1개 | 시전자 ASC 공유 (비용 0) |
| 다단계 스킬 | 불가능 | 소멸 → 다음 DataAsset 소환으로 자연스럽게 연결 |
| 동시 다수 소환 | 구조 없음 | 소환 규칙이 전담 |
| 풀 시스템 활용 | Destroy() 직접 호출 | 풀에 반환 |
| 기획자 사용성 | C++ 필수 | 에디터에서 드롭다운 조합 |
| 코드 중복 | Hit/Overlap 로직 복붙 | 감지→필터→효과 파이프라인으로 통일 |
| 안전장치 | 최대 수명 없음 | 최대 수명 기본 30초 |

---

## 10. 구현 순서

### 단계 1: 뼈대 만들기
1. `AOKSkillObject` 단일 액터 클래스 (기존 `AUKInstancePoolActor` 상속)
2. `UOKSkillObjectDataAsset` (PrimaryDataAsset)
3. 6개 정책 베이스 클래스 (Movement, Detection, Filter, Effect, Timing, Lifetime)
4. 소환 규칙 베이스 클래스 (SpawnRule)

### 단계 2: 핵심 정책 구현
1. Movement: 정지, 직선, 유도
2. Detection: 구체
3. Filter: 적만
4. Effect: 데미지
5. Timing: 접촉시, 주기적
6. Lifetime: 시간, 첫적중
7. SpawnRule: 앞에서, 지정위치

### 단계 3: 어빌리티 연동
1. `UOKGameplayAbility_SkillObject` (스킬 오브젝트 소환 전용 어빌리티)
2. 시전자 ASC를 통한 GE 적용 연동
3. 오브젝트 풀 연동

### 단계 4: 추가 정책 확장
1. Movement: 공전, 부메랑, 낙하, 물결, 확장고리
2. Detection: 박스, 부채꼔, 고리
3. Filter: 아군만, 태그기반, 복합
4. Effect: 힐, 버프, 밀어내기, 복합
5. Timing: 소멸시, 연쇄, 지연
6. Lifetime: 적중횟수, 벽충돌, 사거리, 복합
7. SpawnRule: 부채꼬, 원형, 하늘에서, 랜덤

### 단계 5: 연출과 마무리
1. 나이아가라 이펙트 연동 (소환/비행/적중/소멸)
2. 사운드 연동
3. 카메라 흔들림
4. GameplayCue 연동
5. 디버그 시각화 도구

---

## 11. 기술 세부사항

### UObject 정책 선언 방식

모든 정책은 이 형태를 따른다:
```
UCLASS(Abstract, EditInlineNew, DefaultToInstanced, CollapseCategories)
class UOKMovement : public UObject
```

- `EditInlineNew`: DataAsset 안에서 직접 편집 가능
- `DefaultToInstanced`: 각 DataAsset이 자기만의 인스턴스 보유
- `CollapseCategories`: 에디터에서 깔끔하게 표시

DataAsset에서 참조할 때:
```
UPROPERTY(EditAnywhere, Instanced)
TObjectPtr<UOKMovement> Movement;
```

에디터에서 드롭다운으로 `UOKMovement_Straight`, `UOKMovement_Homing` 등을 선택하면 해당 클래스의 파라미터만 표시된다.

### 오브젝트 초기화 흐름

```
SkillObject가 풀에서 꺼내짐
  ↓
Initialize(DataAsset, Context) 호출
  ↓
DataAsset에서 6개 정책 읽기
  ↓
각 정책.Initialize(SkillObject, Context)
  ↓
Movement 시작, Detection 활성화
  ↓
Tick 시작
```

### Tick에서 하는 일

```
매 프레임:
  1. Movement.Tick(DeltaTime) → 위치 이동
  2. Lifetime.Tick(DeltaTime) → 소멸 조건 확인
     → 소멸이면 → OnExpire() 실행 → 풀에 반환
  3. Timing.Tick(DeltaTime)   → 주기적 타이밍이면 감지 실행
```

감지는 Tick이 아닌 **충돌 이벤트** 또는 **타이밍의 주기적 호출**로 동작한다.
불필요한 매 프레임 검사를 피한다.

### 시전자 정보 구조체

```
FOKSkillObjectContext
  ├── 시전자 액터 (TWeakObjectPtr<AActor>)
  ├── 시전자 ASC (TWeakObjectPtr<UAbilitySystemComponent>)
  ├── 타겟 액터 (TWeakObjectPtr<AActor>) — 없을 수 있음
  ├── 타겟 위치 (FVector) — 없을 수 있음
  ├── GE 스펙 핸들 (FGameplayEffectSpecHandle)
  ├── 시전자 팀 태그 (FGameplayTag)
  └── 전투 데이터 행 이름 (FName)
```

### 풀 시스템 활용

```
소환 시: Pool.Get<AOKSkillObject>() → Initialize()
소멸 시: Cleanup() → Pool.Return(this)

Cleanup()에서 하는 일:
  - 모든 정책.Cleanup() 호출
  - DamagedActors 초기화
  - 충돌 이벤트 해제
  - Tick 비활성화
  - 이펙트 정리
```

---

## 12. 기존 시스템과의 호환성

### 유지하는 것
- `AUKInstancePoolActor` 상속 (풀 시스템)
- `EntityManager`의 `QueryRelation()` (관계 판정)
- `UUKSkillComponent` + `UUKSkillAbility` (스킬 시스템)
- `FGameplayTag` 기반 팀/면역 시스템
- `GameplayEffect`를 통한 데미지/힐/버프

### 바꾸는 것
- 오브젝트별 ASC → 시전자 ASC 공유
- 클래스별 파라미터 구조체 → DataAsset + 정책 조합
- Destroy() 직접 호출 → 풀에 반환
- 충돌 토글 해킹 → 타이머 기반 주기적 감지
- 동기 에셋 로딩 → 비동기 로딩 또는 사전 로딩

### 기존 코드 제거 대상
- `AUKProjectileBase` → 새 시스템의 DataAsset으로 대체
- `AUKAoEObjectBase` → 새 시스템의 DataAsset으로 대체
- `AUKShockwaveBase` → 새 시스템의 DataAsset으로 대체
- `FUKProjectileParams`, `FUKAoEAttackInfo`, `FUKShockwaveAttackInfo` → 정책 파라미터로 대체

`AUKSkillObjectBase`는 새로운 `AOKSkillObject`의 토대로 리팩토링하거나 교체한다.

---

## 13. 정리

### 한 줄 요약

> **하나의 스킬 오브젝트 액터** + **6개 교체 가능한 조각** + **DataAsset 조합** = 코드 수정 없이 무한한 스킬

### 핵심 장점

1. **C++ 수정 없이 새 스킬 생성** — DataAsset에서 드롭다운 6개 선택
2. **일관된 필터링** — 모든 오브젝트가 같은 필터 파이프라인 사용
3. **가벼움** — 오브젝트별 ASC 없음, 시전자 ASC 공유
4. **다단계 스킬** — 소멸 → 다음 DataAsset 연결로 자연스러운 연쇄
5. **안전함** — 최대 수명 안전장치, 풀 반환, 비동기 로딩
6. **확장 쉬움** — 새 이동 방식 = UObject 하위 클래스 1개 추가 (기존 코드 수정 없음)
